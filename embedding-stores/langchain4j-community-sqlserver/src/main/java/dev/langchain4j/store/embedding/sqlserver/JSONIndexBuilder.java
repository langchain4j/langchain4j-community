package dev.langchain4j.store.embedding.sqlserver;

import static dev.langchain4j.internal.ValidationUtils.ensureNotBlank;
import static dev.langchain4j.internal.ValidationUtils.ensureNotNull;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * <p>
 *   This index builder allows to configure JSON indexes on one or several keys of the
 *   metadata column of the {@link EmbeddingTable} using SQL Server 2025 JSON index syntax.
 * </p>
 * <p>
 *   It creates JSON indexes using SQL Server 2025's CREATE JSON INDEX statement which
 *   provides optimized access to JSON data stored in the metadata column.
 * </p>
 */
public class JSONIndexBuilder extends IndexBuilder<JSONIndexBuilder> {

    /**
     * List of JSON keys that will be indexed.
     */
    private final List<MetadataKey> indexExpressions = new ArrayList<>();

    /**
     * Use ASC or DESC to indicate whether the index should be created in ascending or
     * descending order.
     */
    public enum Order {
        /**
         * Create the index in ascending order.
         */
        ASC,
        /**
         * Create the index in descending order.
         */
        DESC
    }

    JSONIndexBuilder() {}

    /**
     * Adds a JSON key to be indexed.
     *
     * @param key   The JSON key to index.
     * @param keyType The Java class of the metadata value.
     * @param order The order the index should be created in.
     * @return This builder.
     * @throws IllegalArgumentException If the key is null or empty, if the keyType is null or if the order is null
     */
    public JSONIndexBuilder key(String key, Class<?> keyType, Order order) {
        ensureNotBlank(key, "key");
        ensureNotNull(keyType, "keyType");
        ensureNotNull(order, "order");
        indexExpressions.add(new MetadataKey(key, keyType, order));
        return this;
    }

    /**
     * Adds a JSON key to be indexed with default ascending order.
     *
     * @param key   The JSON key to index.
     * @param keyType The Java class of the metadata value.
     * @return This builder.
     * @throws IllegalArgumentException If the key is null or empty, if the keyType is null
     */
    public JSONIndexBuilder key(String key, Class<?> keyType) {
        return key(key, keyType, Order.ASC);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Index build() {
        return new Index(this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    String getCreateIndexStatement(EmbeddingTable embeddingTable) {

        StringBuilder forClause = new StringBuilder();
        // Add JSON paths for the keys to be indexed
        if (!indexExpressions.isEmpty()) {
            forClause.append(" FOR (");
            String paths = indexExpressions.stream()
                    .map(key -> "'$." + key.key() + '\'')
                    .collect(Collectors.joining(", "));
            forClause.append(paths);
            forClause.append(')');
        }

        return String.format("CREATE JSON INDEX %s ON %s(%s) %s",
                getIndexName(embeddingTable), embeddingTable.getQualifiedTableName(), embeddingTable.metadataColumn(), forClause);

    }

    /**
     * {@inheritDoc}
     * <p>
     *   The index name is generated by concatenating "_JSON_" and the indexed key
     *   names separated by an underscore character to the embedding table name.
     * </p>
     */
    @Override
    String getIndexName(EmbeddingTable embeddingTable) {
        if (indexName == null) {
            String suffix = "_JSON_";
            if (!indexExpressions.isEmpty()) {
                suffix += indexExpressions.stream()
                        .map(metadataKey -> metadataKey.key().toUpperCase())
                        .collect(Collectors.joining("_"));
            } else {
                suffix += "ALL";
            }
            indexName = buildIndexName(embeddingTable.name(), suffix);
        }
        return indexName;
    }

    /**
     * Private class that represents a metadata key to be indexed.
     */
    private record MetadataKey(String key, Class<?> keyType, Order order) {
    }
}
